## 1、在结构化数据抽取时，主动学习的基本原理是什么？什么是协同测试？
主动学习的模型如下:
A=(C,Q,S,L,U)，
其中 C 为一组或者一个分类器，L是用于训练已标注的样本。Q 是查询函数，用于从未标注样本池U中查询信息量大的信息，S是督导者，可以为U中样本标注正确的标签。学习者通过少量初始标记样本L开始学习，通过一定的查询函数Q选择出一个或一批最有用的样本，并向督导者询问标签，然后利用获得的新知识来训练分类器和进行下一轮查询。主动学习是一个循环的过程，直至达到某一停止准则为止。

自动化测试环境很重要的一个挑战是难以适用被测对象和测试业务的变化， UTP协同测试平台支持分布式部署不同类型的测试机器人，通过新的测试机器人来灵活调整自动化测试环境，满足被测对象和测试业务的变化需求。
不同的测试机器人实现不同的测试功能，比如：界面测试机器人实现对用户的操作界面做自动化测试，网络通信测试机器人可以实现对网络通信过程进行自动化测试，仪器控制机器人可以自动控制仪器进行自动化测试。

## 2、什么是包装器维护？主要包括什么内容？
包装器就是将数据从网页中抽取出来，并将数据还原为结构化数据。包装器归纳是基于有监督学习的，它从标注好的训练样例集合中学习数据抽取规则，用于从其它相同标记或相同网页模板中抽取目标数据。
包装器归纳主要包括网页清洗、网页标注、包装器空间生成、包装器评估、包装器归纳结果等步骤。


## 3、什么是完美析取规则？
析取引入规则 （简记V+） 如下是析取消去规则的例示： “佳士德拍卖公司拍卖的圆明园兽首或者拍卖成功或者流拍。 圆明园兽首没有拍卖成功。 所以，圆明园兽首流拍。 ”
析取概念（disjunctive concept）是指根据不同的标准，结合单个或多个属性所形成的概念。按析取规则 构成的概念。包含的事物可同时具备两个要求的属性，也可只涉及其中之。
基于规则的分类器所产生的规则集的两个重要性质：
互斥规则 如果规则集R中不存在两条规则被同一条记录触发，则称规则集R中的规则是互斥的。这个性质确保每条记录至多被R中的一条规则覆盖。
穷举规则 如果对属性值的任意组合，R中都存在一条规则加以覆盖，则称规则集R具有穷举覆盖。这个性质确保每一条记录都至少被R中的一条规则覆盖。
这两个性质共同作用，保证每一条记录被且仅被一条规则覆盖。如果规则集不是穷举的，那么必须添加一个默认规则 rd:() → yd来覆盖那些未被覆盖的记录。默认规则的前件为空，当所有其他规则失效时触发。yd是默认类，通常被指定为没有被现存规则覆盖的训练记录的多数类。


## 4、什么是串的编辑距离？什么是树的编辑距离？
Levenshtein 距离，又称编辑距离，指的是两个字符串之间，由一个转换成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。编辑距离的算法是首先由俄国科学家 Levenshtein 提出的，故又叫 Levenshtein Distance 。

计算树的编辑距离就是求从一棵树转换为另一棵树所需要树的编辑操作的最少次数。 假设现在对两棵树T和T’求解编辑距离，首先要找到他们之间的映射，也就是相同的部分，然后再对不同的部分进行操作进行转换。


## 5、试用课堂上讲的矩阵算法求解下面两个串的编辑距离。S1=XGYXYYX，S2=XYXYXTX
| -   | -   | X   | G   | Y   | X   | Y   | Y   | X   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| -   | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| X   | 1   | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
| Y   | 2   | 1   | 1   | 2   | 3   | 4   | 5   | 6   |
| X   | 3   | 2   | 1   | 2   | 2   | 3   | 4   | 5   |
| Y   | 4   | 3   | 2   | 1   | 2   | 2   | 3   | 4   |
| X   | 5   | 4   | 3   | 2   | 1   | 2   | 3   | 4   |
| T   | 6   | 5   | 4   | 3   | 2   | 2   | 3   | 4   |
| X   | 7   | 6   | 5   | 4   | 3   | 2   | 3   | 3   |


## 6、STM算法的主要原理是什么？试给出算法描述。
令 A A A 和 B B B为两棵树, i i i 和 j j j 分别为 A A A和 B B B上的结点.

A = ( R A , A 1 , ⋯   , A m ) B = ( R B , B 1 , ⋯   , B n ) A=\\left(R\_{\\mathrm{A}}, A\_{1}, \\cdots, A\_{m}\\right) \\\\ B=\\left(R\_{\\mathrm{B}}, B\_{1}, \\cdots,B\_{n}\\right) A\=(RA​,A1​,⋯,Am​)B\=(RB​,B1​,⋯,Bn​)

其中， R A R\_{\\mathrm{A}} RA​ 和 R B R\_{\\mathrm{B}} RB​是 A A A和 B B B的根结点， A i A\_{i} Ai​ 和 B j B\_{j} Bj​分别是 A A A和 B B B的第 i i i个和第 j j j个第1层子树.

（1）当 R A R\_{A} RA​和 R B R\_{B} RB​的标记相同时, A A A和 B B B的最大匹配为 M A , B + 1 M\_{{A}, {B}}+1 MA,B​+1, 其中 M A , B M\_{{A}, {B}} MA,B​ 是 ⟨ A 1 , A 2 , ⋯   , A m ⟩ \\left\\langle A\_{1}, A\_{2}, \\cdots, A\_{m}\\right\\rangle ⟨A1​,A2​,⋯,Am​⟩ 和 ⟨ B 1 , B 2 , ⋯   , B n ⟩ \\left\\langle B\_{1},B\_{2}, \\cdots, B\_{n}\\right\\rangle ⟨B1​,B2​,⋯,Bn​⟩ 的最大匹配。 M A , B M\_{\\mathrm{A}, \\mathrm{B}} MA,B​ 可以通过动态规划算法得到。  
（2）当 R A R\_{A} RA​和 R B R\_{B} RB​的标记不相同时，返回0

